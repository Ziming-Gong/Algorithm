package WeeklyPractice.Jan022023;

import com.sun.xml.internal.xsom.XSWildcard;
import sun.util.resources.in.CurrencyNames_in_ID;

import java.rmi.ConnectIOException;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;

public class LC928MinimizeMalwareSpreadII {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        HashSet<Integer> set = new HashSet<>();
        for (int i : initial) {
            set.add(i);
        }
        int n = graph.length;
        UnionFind uf = new UnionFind(n);
        for (int i = 0; i < n; i++) {
            if (set.contains(i)) {
                continue;
            }
            for (int j = i + 1; j < n; j++) {
                if (set.contains(j)) {
                    continue;
                }
                if (graph[i][j] == 1) {
                    uf.union(i, j);
                }
            }
        }
        int[] infect = new int[n + 1];
        int[] cnt = new int[n + 1];
        // infect[i] = -1  表示还没有用过
        // infect[i] = -2  表示有多个感染源
        // infect[i] >= 0  表示有一个感染源
        for (int i : initial) {
            for (int next = 0; next < n; next++) {
                if (i == next || set.contains(next) || graph[i][next] == 0) {
                    continue;
                }
                int father = uf.find(next);
                if (infect[father] == -1) {
                    cnt[i] -= uf.size[father];
                    infect[father] = i;
                } else if (infect[father] >= 0) {
                    cnt[i] += uf.size[father];
                    infect[father] = -1;
                }
            }
        }
        int ans = Integer.MIN_VALUE;
        for (int i = 0; i < cnt.length; i++) {
            ans = Math.max(ans, cnt[i]);
        }
        return ans;

    }

    public class UnionFind {
        public int[] father;
        public int[] help;
        public int[] size;
        public int N;


        public UnionFind(int n) {
            N = n;
            father = new int[n];
            help = new int[n];
            size = new int[n];
            for (int i = 0; i < n; i++) {
                size[i] = 1;
                father[i] = i;
            }
        }

        public int find(int index) {
            int len = 0;
            while (father[index] != index) {
                help[len++] = index;
                index = father[index];
            }
            while (len > 0) {
                father[help[--len]] = index;
            }
            return index;
        }

        public void union(int a, int b) {
            int fatherA = find(a);
            int fatherB = find(b);
            if (fatherA != fatherB) {
                int sizeA = size[fatherA];
                int sizeB = size[fatherB];
                if (sizeA >= sizeB) {
                    father[fatherB] = fatherA;
                    size[fatherA] += sizeB;
                } else {
                    father[fatherA] = fatherB;
                    size[fatherB] += sizeA;
                }
            }
        }

    }
}
